## 项目结构

| 源码目录      | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| api/          | 存放OpenAPI/Swagger的spec文件，包括JSON、Protocol的定义等    |
| build/        | 存放与构建相关的脚本                                         |
| cmd/          | 存放可执行文件的入口代码，每个可执行文件都会对应一个main函数 |
| docs/         | 存放设计或用户使用文档                                       |
| hack/         | 存放与构建、测试等相关的脚本                                 |
| pkg/          | 存放核心库代码，可被项目内部或外部直接引用                   |
| plugin/       | 存放kubernetes插件代码目录，例如认证、授权等相关插件         |
| staging/      | 存放部分核心库的暂存目录                                     |
| test/         | 存放测试工具及测试数据                                       |
| third-party/  | 存放第三方工具、代码或其他组件                               |
| translations/ | 存放i18n(国际化)语言包的相关文件                             |
| vendor/       | 存放项目依赖的库代码，一般为第三方仓库代码                   |

## cmd内组件的main函数

main函数定义了程序运行的周期，包括从进程启动、运行到退出的过程。

Start -> rand.Seed -> app.NewCommand() (包括参数、选项的初始化) -> logs.InitLogs() -> command.Execute() -> opts.Complete() -> opts.Validate() -> Run() -> stop chan -> End

- rand.Seed: 组件中的全局随机数生成对象
- app.NewCommand: 实例化命令行参数。通过flags对命令行参数进行解析并存储至Options对象中
- logs.InitLogs: 实例化日志对象，用于日志管理
- command.Execute: 组件进程运行的逻辑。运行前通过Complete函数填充默认参数，通过Validate函数验证所有参数，最后通过Run函数持久运行。只有当进程收到退出信号时，进程才会退出。

## 代码生成器

| 代码生成器     | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| conversion-gen | 自动生成Convert函数的代码生成器，用于资源对象的版本转换函数  |
| deepcopy-gen   | 自动生成DeepCopy函数的代码生成器，用于资源对象的深复制函数   |
| defaulter-gen  | 自动生成Defaulter函数的代码生成器，用于资源对象的默认值函数  |
| go-bindata     | 第三方工具，能够将静态资源文件嵌入Go语言中                   |
| openapi-gen    | 自动生成OpenAPI定义文件（OpenAPI Definition File）的代码生成器 |

代码生成器通过Tags(标签)来识别一个包是否需要生成代码及确定生成代码的方式。

- 全局Tags：定义在每个包的`doc.go`文件中，对整个包中的类型自动生成代码。

  定义在`pkg/apis/<group>/<version>/doc.go`中

  ```go
  // +k8s:deepcopy-gen=package
  // +k8s:conversion-gen=k8s.io/kubernetes/pkg/apis/abac
  // +k8s:openapi-gen=true
  // +k8s:defaulter-gen=TypeMeta
  
  // +groupName=abac.authorization.kubernetes.io
  package v1beta1 // import "k8s.io/kubernetes/pkg/apis/abac/v1beta1"
  ```

  全局Tags告诉`deepcopy-gen`代码生成器为该包中的每个类型自动生成`DeepCopy`函数。其中`// +groupName`定义了资源组名称，资源组名称一般使用域名形式命名。

- 局部Tags: 定义在Go语言的类型声明尚房，只对特定的类型自动生成代码。

  例如：`/pkg/apis/core/types.go`
  
  ```go
  // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
  
  // PersistentVolume struct captures the details of the implementation of PV storage
  type PersistentVolume struct {
  	metav1.TypeMeta
  	// +optional
  	metav1.ObjectMeta
  
  	//Spec defines a persistent volume owned by the cluster
  	// +optional
  	Spec PersistentVolumeSpec
  
  	// Status represents the current information about persistent volume.
  	// +optional
  	Status PersistentVolumeStatus
  }
  ```
  
  局部Tags定义在`PersistentVolume`资源类型的上方，定义了该类型的代码生成器`deepcopy-gen`为这个资源类型自动生成`DeepCopy`函数。
  
  

#### 1、DeepCopy-gen代码生成器

自动生成`DeepCopy`函数的代码生成器。给定一个包的目录路径作为输入源，它可以为其生成`DeepCopy`相关的函数，这些函数可以有效地执行每种类型的深复制操作。

为每个包生成`DeepCopy`相关的函数时，其`Tags`形式如下：

```go
// +k8s:deepcopy-gen=package
```

当为单个类型生成`DeepCopy`相关函数时，其`Tags`形式如下：

```go
// +k8s:deepcopy-gen=true
```

为整个包生成DeepCopy相关函数时，可以忽略单个类型，其`Tags`形式如下：

```go
// +k8s:deepcopy-gen=false
```

有时在`kubernetes`源码里会看到`deepcopy-gen`的`Tags`被定义成`runtime.Object`，这时`deepcopy-gen`会为该类型生成返回值为`runtime.Object`类型的`DeepCopyObject`函数。

```go
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Pod is a collection of containers, used as either input (create, update) or as output (list, get).
type Pod struct {
	metav1.TypeMeta
	// +optional
	metav1.ObjectMeta

	// Spec defines the behavior of a pod.
	// +optional
	Spec PodSpec

	// Status represents the current information about a pod. This data may not be up
	// to date.
	// +optional
	Status PodStatus
}
```
```go
// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Pod) DeepCopyInto(out *Pod) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
	return
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Pod.
func (in *Pod) DeepCopy() *Pod {
	if in == nil {
		return nil
	}
	out := new(Pod)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Pod) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}
```


#### deepcopy-gen的使用示例

1、生成二进制文件(只能在linux和macOS生成)
```bash
$ hack/make-rules/build.sh staging/src/k8s.io/code-generator/cmd/deepcopy-gen
$  ./_output/bin/deepcopy-gen --v 1 --logtostderr -i "k8s.io/kubernetes/pkg/apis/abac/v1beta1" --bounding-dirs k8s.io/kubernetes,"k8s.io/api" -O zz_generated.deepcopy
```

[deep-copy源码](https://github.com/kubernetes/gengo/tree/master/examples/deepcopy-gen)

## kubernetes核心数据结构

- Group(资源组):在Kubernetes API Server中也可以被称为APIGroup
- Version(版本资源):在Kubernetes API Server中也可以被称为APIVersions
- Resource(资源):在Kubernetes API Server中也可以被称为APIResource
- Kind(资源种类):描述Resource的种类，与Resource为同一级别

完整的表现形式为<group>/<version>/<resource>/<subresource>.例如Deployment资源为例，其完整表现形式为`apps/v1/deployments/status`.

可以通过Group、Version、Resource结构来明确标识一个资源的资源组名称、资源版本和资源名称。

代码路径：[staging\src\k8s.io\apimachinery\pkg\runtime\schema\group_version.go#L96]

```go
type GroupVersionResource struct {
	Group    string
	Version  string
	Resource string
}
```
以Deployment资源为例，资源信息描述信息如下：
```go
schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "deployments"}
```

### Group(资源组)

- 将众多资源按照功能划分成不同的资源组，并允许单独启用/禁用资源组。当然也可以单独启用/禁用资源组中的资源。
- 支持不同资源组中拥有不同的资源版本。方便组内的资源根据版本进行迭代升级
- 支持同名的资源种类（Kind）存在于不同的资源组内
- 资源组与资源版本通过Kubernetes API Server对外暴露，允许开发者通过HTTP协议进行交互并通过动态客户端（即DynamicClient）进行资源发现
- 支持CRD自定义资源扩展
- 用户交互简单，例如在使用kubectl命令行工具时，可以不填写资源组名称

在当前kubernetes系统中，支持两类资源，分别是拥有组名的资源组合没有组名的资源组
- 拥有组名的资源组：<group>/<version>/<resource>,apps/v1/deployments，它的HTTP Path为/apis/apps/v1/deployments
- 没有组名的资源组：被称为Core Groups(核心资源组),<version>/<resource>,/v1/pods，它的HTTP Path为/api/v1/pods

### Version(资源版本)

Alpha->Beta->Stable.
- Alpha:一般用于内部测试,可能存在很多缺陷和漏洞，随时可能放弃支持该版本。版本名称一般为v1alpha1,v1alpha2,v2alpha1
- Beta:相对稳定版本，该版本已经修复了大部分不完善之处，但仍可能存在缺陷和漏洞，当功能迭代时，改版本会有较小变化但不会删除。处于Beta版本功能是开启状态。版本名称一般为v1beta1,v1beta2,v2beta1
- Stable:基本形成产品并达到一定的成熟度，可稳定运行,不会被删除。版本名称一般为v1,v2,v3

下面以apps为例：
- v1: ControllerRevisions,DaemonSets,Deployments,ReplicaSets,StatefulSets
- v1beta1: ControllerRevisions,Deployments,StatefulSets
- v1beta2: ControllerRevisions,DaemonSets,Deployments,ReplicaSets,StatefulSets

### Resource(资源)

kubernetes系统虽然有相当复杂和众多的功能，但它本质上是一个资源控制系统---管理、调度资源并维护资源的状态。

一个资源被实例化后会表达一个资源对象（即Resource Object）。在kubernetes系统中定义并运行各式各样的资源对象。
所有的资源对象都是`Entity`（实体）。
- 持久性实体(Persistent Entity)：在资源对象被创建后，kubernetes会持久确保该资源对象存在。大部分资源对象属于持久性实体，例如Deployment资源对象
- 短暂性实体(Ephemeral Entity)：在资源对象被创建后，如果出现故障或调度失败，不会重新创建该资源对象，例如Pod资源对象

### 资源外部版本和内部版本

kubernetes资源代码定义在`pkg/apis`目录下。例如，Deployment资源外部版本表现形式为`apps/v1`，内部版本表现形式为`apps/_internal`。

- External Object：外部版本资源对象。外部版本用于对外暴露给用户请求的接口所使用的资源对象。
例如，用户在通过YAML或JSON格式的描述文件创建资源对象时，所使用的的是外部资源对象。外部版本代码定义在`pkg/apis/<group>/<version>`
- Internal Object：内部版本资源对象。内部版本不对外暴露，仅在kubernetes api server内部使用。
内部版本用于多资源版本的切换。例如v1beta1->internal->v1。内部版本代码定义在`pkg/apis/<group>`

Pod资源外部版本代码定义如下:[staging/src/k8s.io/api/core/v1/types.go]
```go
type Pod struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
	Spec PodSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
	Status PodStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
}
```
Pod资源内部版本代码定义如下:[pkg/apis/core/types.go]
```go
type Pod struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec PodSpec
	Status PodStatus
}
```

#### 资源代码定义

资源内部版本定义了所支持的资源类型(types.go)，资源校验方法(validation.go)，资源注册值资源注册表的方法(install/install.go)等。
资源外部版本定义了资源的转换方法(conversion.go),资源的默认值(defaults.go)等。

以Deployment资源为例，内部版本定义在`pkg/apis/apps`目录下。
```bash
fuzzer
install：把当前资源组下的所有资源注册到资源注册表中
v1      -|
v1beta1 -|  定义了资源组下拥有的资源版本的资源（即外部版本）
v1beta2 -|
validation：定义了资源的验证方法
doc.go：GoDoc文件，定义了当前包的注释信息
register.go：定义了资源组、资源版本即资源的注册信息
types.go ：定义了在当前资源、资源版本下所支持的资源类型
zz_generated.deepcopy.go：定义了资源的深复制操作，由代码生成器生成
```

每一个kubernetes资源目录，都通过`register.go`代码文件定义所属的资源组和资源版本，内部资源版本对象通过`runtime.APIVersionInternal`(即__internal)标识。
[pkg/apis/apps/register.go]
```go
// GroupName is the group name use in this package
const GroupName = "apps"

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: runtime.APIVersionInternal}
```

每一个kubernetes资源目录，都通过`types.go`代码文件定义在当前资源组/资源版本下所支持的资源类型。

资源外部版本定义在`pkg/apis/apps/{v1,v1beta1,v1beta2}`
```bash
conversion.go：定义了资源的转换函数（默认转换函数），并将默认转换函数注册到资源注册表中
defaults.go：定义了资源的默认值函数，并将默认值函数注册到资源注册表中
doc.go
register.go
zz_generated.conversion.go：定义资源的转换函数（自动生成的转换函数），并将生成的转换函数注册到资源注册表中。该文件由代码生成器自动生成
zz_generated.defaults.go：定义了资源的默认值函数（自动生成的转换函数），并将生成的转换函数注册到资源注册表中。该文件由代码生成器自动生成
```

外部版本资源对象通过版本资源（Alpha，Beta，Stable）标识，
```go
// GroupName is the group name use in this package
const GroupName = "apps"

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: "v1beta1"}
```

#### 将资源注册到资源注册表中

在每一个kubernetes资源组目录中，都拥有一个`install/install.go`代码文件，它负责将资源信息注册到资源注册表中(Scheme)中。
```go
func init() {
	Install(legacyscheme.Scheme)
}

// Install registers the API group and adds types to a scheme
func Install(scheme *runtime.Scheme) {
	utilruntime.Must(apps.AddToScheme(scheme))
	utilruntime.Must(v1beta1.AddToScheme(scheme))
	utilruntime.Must(v1beta2.AddToScheme(scheme))
	utilruntime.Must(v1.AddToScheme(scheme))
	utilruntime.Must(scheme.SetVersionPriority(v1.SchemeGroupVersion, v1beta2.SchemeGroupVersion, v1beta1.SchemeGroupVersion))
}
```

`legacyscheme.Scheme`是`kube-apiserver`组件的全局注册表，kubernetes的所有资源信息都交给资源注册表统一管理。
`apps.AddToScheme`函数注册`apps`资源组内部版本资源。`v1beta1.AddToScheme`函数注册`apps`资源组外部版本的资源。
`scheme.SetVersionPriority`函数注册资源组的版本顺序，排在前面的为资源首选版本。

#### 资源首选版本

首选版本(Preferred Version)，也称为优选版本(Priority Version),一个资源组下拥有多个资源版本，例如apps资源组拥有v1，v1beta1,v1beta2等资源版本。
当我们使用apps资源组下的Deployment资源时，在一些场景下，如不指定资源版本，则使用该资源的首选版本。

当通过注册表`scheme.PreferredVersionAllGroups`函数获取所有资源组下的首选版本时，将位于最前面的资源版本作为首选版本。
[staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go]
```go
func (s *Scheme) PreferredVersionAllGroups() []schema.GroupVersion {
	ret := []schema.GroupVersion{}
	for group, versions := range s.versionPriority {
		for _, version := range versions {
			ret = append(ret, schema.GroupVersion{Group: group, Version: version})
			break
		}
	}
	...

	return ret
}
```

- `scheme.PrioritizedVersionsForGroup`获取指定资源组的资源版本，按照优先顺序返回
- `scheme.PrioritizedVersionsAllGroups`获取所有资源组的资源版本，按照优先顺序返回

### 资源操作方法

在kubernetes系统中，针对每一个资源都有一定的操作方法(即Verbs)。

资源操作方法可以通过`metav1.Verbs`进行描述,[staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/types.go]
```go
type Verbs []string

func (vs Verbs) String() string {
	return fmt.Sprintf("%v", []string(vs))
}
``` 

不同的资源拥有不同的操作方法，例如针对Pod资源对象与pod/logs子资源对象，pod资源对象有create、delete、deletecollection、get、list、patch、update、watch等，而logs只有get操作方法。

资源对象的操作方法与存储(Storage)相关联，增删改查实际上是针对存储的操作，定义在[staging/src/k8s.io/apiserver/pkg/registry/rest]

[staging/src/k8s.io/apiserver/pkg/registry/rest/rest.go]
```go
type Getter interface {
	Get(ctx context.Context, name string, options *metav1.GetOptions) (runtime.Object, error)
}
type Creater interface {
	New() runtime.Object
	Create(ctx context.Context, obj runtime.Object, createValidation ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, error)
}
```

可以认为如果某个资源对象在存储(Storage)实现方法Get,New,Create，就认为该资源对象拥有了get和create方法。

以Pod资源对象为例，Pod资源对象的存储实现了以上接口的方法，Pod资源对象集成了`genericregistry.Store`，该对象可以管理存储的增删改查。

[pkg/registry/core/pod/storage/storage.go]
```go
type PodStorage struct {
	Pod                 *REST
	Binding             *BindingREST
	LegacyBinding       *LegacyBindingREST
	Eviction            *EvictionREST
	Status              *StatusREST
	EphemeralContainers *EphemeralContainersREST
	Log                 *podrest.LogREST
	Proxy               *podrest.ProxyREST
	Exec                *podrest.ExecREST
	Attach              *podrest.AttachREST
	PortForward         *podrest.PortForwardREST
}
type REST struct {
	*genericregistry.Store
	proxyTransport http.RoundTripper
}
```
[staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go]
```go
func (e *Store) Create(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, error) {
    ...
}
```
[pkg/registry/core/pod/rest/log.go]
```go
func (r *LogREST) Get(ctx context.Context, name string, opts runtime.Object) (runtime.Object, error) {
    ...
}
```

#### 资源与命名空间

kubernetes系统支持命名空间(Namespace)，其用来解决kubernetes集群中资源对象过多导致管理复杂的问题。
每个命名空间相当于一个“虚拟集群”，不同命名空间之间可以进行隔离，当然也可以进行某种方式跨命名空间通信。

kubernetes系统默认内置4个命名空间
- default：所有未指定命名空间的资源对象都会被分配到该命名空间
- kube-system：所有由kubernetes系统创建的资源对象都会被分配给该命名空间
- kube-public：此命名空间下的资源对象可以被所有人访问（包括未认证用户）
- kube-node-lease：此命名空间下存放来自接地那的心跳记录（节点租约信息）

### runtime.Object类型基石

kubernetes Runtime在[staging/src/k8s.io/apimachinery/pkg/runtime]中实现，提供了通用资源类型`runtime.Object`。

Kubernetes上所有的资源对象(Resource Object)实际上就是一种Go语言的Struct类型，相当于一种数据结构，他们都有一个共同的结构叫`runtime.Object`。
`runtime.Object`被设计为Interface接口类型，作为资源对象的通用资源对象。

以资源对象Pod为例，该资源对象可以转换成`runtime.Object`，也可以从`runtime.Object`通用资源对象转成Pod资源对象。
[staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go]
```go
type Object interface {
    // 设置并返回GroupVersionKind
	GetObjectKind() schema.ObjectKind
    // 用于深复制当前资源对象并返回
	DeepCopyObject() Object
}
```
[staging/src/k8s.io/apimachinery/pkg/runtime/schema/interfaces.go]
```go
type ObjectKind interface {
	SetGroupVersionKind(kind GroupVersionKind)
	GroupVersionKind() GroupVersionKind
}
```

kubernetes的每一个资源对象都嵌入了`metav1.TypeMeta`类型，而`metav1.TypeMeta`类型都实现了`GetObjectKind`方法，所以资源对象拥有该方法。
另外，kubernetes的每一个资源都实现了`DeepCopyObject`方法，该方法一般被定义在`zz_generated.deepcopy.go`文件中。因此，可以认为该资源对象能够转换成`runtime.Object`。

#### Unstructured数据

数据可以分成结构化数据(Structured Data)和非结构化数据(Unstructured Data).

1、结构化数据，例如JSON数据，需要创建一个`struct`数据结构，然后进行反序列化，将属性映射到`struct`中。

2、非结构化数据就是无法预知数据结构类型或属性名称不明确的，其也无法通过预订的`struct`数据结构来序列化或反序列化。
无法预知数据类型，因为Go语言是强类型，需要预先知道数据类型，Go语言在处理JSON数据时不如动态语言那样便捷，可以通过`map[string]interface{}`来处理。
```go
if data,ok:=result["data"].(string);ok {
    fmt.Println(data)
}
```
使用interface字段时，通过Go语言断言的方式进行类型转换。

3、kubernetes非结构化数据处理

[staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go]
```go
type Unstructured interface {
	Object
	// NewEmptyInstance returns a new instance of the concrete type containing only kind/apiVersion and no other data.
	// This should be called instead of reflect.New() for unstructured types because the go type alone does not preserve kind/apiVersion info.
	NewEmptyInstance() Unstructured
	// UnstructuredContent returns a non-nil map with this object's contents. Values may be
	// []interface{}, map[string]interface{}, or any primitive type. Contents are typically serialized to
	// and from JSON. SetUnstructuredContent should be used to mutate the contents.
	UnstructuredContent() map[string]interface{}
	// SetUnstructuredContent updates the object content to match the provided map.
	SetUnstructuredContent(map[string]interface{})
	// IsList returns true if this type is a list or matches the list convention - has an array called "items".
	IsList() bool
	// EachListItem should pass a single item out of the list as an Object to the provided function. Any
	// error should terminate the iteration. If IsList() returns false, this method should return an error
	// instead of calling the provided function.
	EachListItem(func(Object) error) error
}
```
[staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/unstructured/unstructured.go]
```go
type Unstructured struct {
	Object map[string]interface{}
}
```

### Scheme资源注册表AddKnownTypes

kubernetes系统中的所有资源类型都已经注册到`Scheme`资源注册表中，其是一个内存型的资源注册表，特点：
- 支持注册多重资源类型，包括内部版本和外部版本
- 支持多种版本转换机制
- 支持不同资源的序列化和反序列化

Scheme资源注册表支持两种资源类型(Type)的注册：
- UnversionedType：无版本资源类型，这是一个早期kubernetes系统中的概念，主要应用于某些没有版本的资源类型，该类型的资源对象不需要进行转化。通过`scheme.AddUnversionedTypes`方法注册
- KnownType：目前kubernetes最常用的资源类型。通过`scheme.AddKnownTypes`方法注册

#### Scheme资源注册表数据结构

[staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go]
```go
type Scheme struct {
    // 存储GVK与Type的映射关系
	gvkToType map[schema.GroupVersionKind]reflect.Type
    // 存储Type与GVK的映射关系，一个Type会对应一个或多个GVK
	typeToGVK map[reflect.Type][]schema.GroupVersionKind
    // 存储UnversionedType与GVK的映射关系
	unversionedTypes map[reflect.Type]schema.GroupVersionKind
	// 存储Kind（资源种类）名称与UnversionedType的映射关系
	unversionedKinds map[string]reflect.Type
    ...
}
```

`Scheme`资源注册表通过Go语言的map结构实现映射关系，这些映射关系可以实现高效的正向和反向检索，从`Scheme`资源注册表中检索某个GVK的Type，它的时间复杂度为O(1)

```go
package main

import (
	appsv1 "k8s.io/api/apps/v1"
    corev1 "k8s.io/api/core/v1"
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
    "k8s.io/apimachinery/pkg/runtime"
    "k8s.io/apimachinery/pkg/runtime/schema"
)

func main() {
	// KnowType external
	coreGV := schema.GroupVersion{Group: "",Version: "v1"}
	extensionsGV := schema.GroupVersion{Group: "extensions",Version:"v1beta1"}
	// KnowType internal
	coreInternalGV := schema.GroupVersion{Group: "",Version: runtime.APIVersionInternal}
	// UnversionedType
	Unversioned := schema.GroupVersion{Group: "",Version:"v1"}

	scheme := runtime.NewScheme()
	scheme.AddKnownTypes(coreGV,&corev1.Pod{})
	scheme.AddKnownTypes(extensionsGV, &appsv1.DaemonSet{})
	scheme.AddKnownTypes(coreInternalGV, &corev1.Pod{})
	scheme.AddKnownTypes(Unversioned, &metav1.Status{})
}
```

在上述代码中，首先定义了两种类型的GV（资源组、资源版本），KnowType类型有coreGV、extensionsGV、coreInternalGV对象，其中coreInternalGV对象输入内部版本，而UnversionedType类型有Unversioned对象。

通过`runtime.NewScheme()`实例化一个新的`Scheme`资源注册表。注册资源类型到`Scheme`，我们往`Scheme`资源注册表分别注册了Pod、DaemonSet、Pod（内部版本）、Status（无版本资源）类型对象。
那么这些类型资源的映射关系如下：
- gvkToType： /v1,Kind=Pod:v1.Pod ; extensions/v1beta1,Kind=DaemonSet:v1.DaemonSet  ; /_internal,Kind=Pod:v1.Pod ; /v1,Kind=Status:v1.Status
- typeToGVK: v1.Status:[/v1,Kind=Status] ; v1.Pod:[/v1,Kind=Pod,/_internal,Kind=Pod] ; v1.DaemonSet:[extensions/v1beta1,Kind=DaemonSet]
- unversionedTypes: /v1,Kind=Status:v1.Status
- unversionedKinds: Status:v1.Status

另外，通过`scheme.AddUnversionedTypes`方法注册时，会同时存在4个map结构中
```go
func (s *Scheme) AddUnversionedTypes(version schema.GroupVersion, types ...Object) {
	s.addObservedVersion(version)
    // 这里会注册AddKnownTypes
	s.AddKnownTypes(version, types...)
	for _, obj := range types {
		t := reflect.TypeOf(obj).Elem()
		gvk := version.WithKind(t.Name())
		s.unversionedTypes[t] = gvk
		if old, ok := s.unversionedKinds[gvk.Kind]; ok && t != old {
			panic(fmt.Sprintf("%v.%v has already been registered as unversioned kind %q - kind name must be unique in scheme %q", old.PkgPath(), old.Name(), gvk, s.schemeName))
		}
		s.unversionedKinds[gvk.Kind] = t
	}
}
```

#### 资源注册表注册方法

- scheme.AddUnversionedTypes：注册UnversionedType资源类型
- scheme.AddKnownTypes：注册KnownType资源类型
- scheme.AddKnownTypeWithName：注册KnownType资源类型，须指定资源的Kind资源种类名称

以`scheme.AddKnownTypes`方法为例，在注册资源类型时，无须指定Kind名称，而是通过reflect机制获取资源类型的名称作为资源类型名称。
[staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go]
```go
func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types ...Object) {
	s.addObservedVersion(gv)
	for _, obj := range types {
		t := reflect.TypeOf(obj)
		if t.Kind() != reflect.Ptr {
			panic("All types must be pointers to structs.")
		}
		t = t.Elem()
		s.AddKnownTypeWithName(gv.WithKind(t.Name()), obj)
	}
}
```

#### 资源注册表查询方法

- scheme.KnownTypes：查询注册表中指定GV下的资源类型
- scheme.AllKnownTypes：查询注册表中所有GVK下的资源类型
- scheme.ObjectKinds：查询资源对象所对应的GVK，一个资源对象可能存在多个GVK
- scheme.New：查询GVK所对应的资源对象
- scheme.IsGroupRegistered：判断指定的资源组是否已经注册
- scheme.IsVersionRegistered：判断指定的GV是否已经注册
- scheme.Recognizes：判断指定的GVK是否已经注册
- scheme.IsUnversioned：判断指定的资源对象是否属于UnversionedType类型

### Codec编解码器

先了解一下Codec编码器与Serializer序列化器之间的差异
- Serializer：序列化器，包含序列化操作与反序列化操作。序列化操作是将数据（例如数组、对象或结构体等）转换为字符串的过程，反序列化操作是将字符串转换为数据的过程，因此可以轻松的维护数据结构并存储或传输数据。
- Codec：编解码器，包含编码器和解码器。编解码器是一个通用术语，指的是可以表示数据的任何格式，或者将数据转换为特定格式的过程。所以，可以将Serializer序列化器理解为Codec编解码器的一种。

[staging/src/k8s.io/apimachinery/pkg/runtime/interfaces.go]
```go
type Codec Serializer

type Serializer interface {
	Encoder
	Decoder
}
type Decoder interface {
	Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)
}
type Encoder interface {
	Encode(obj Object, w io.Writer) error
	Identifier() Identifier
}
```

从Codec编解码器通用接口的定义可看出，Serializer序列化器属于Codec编解码器的一种，这是因为每种序列化器都实现了`Encoder`和`Decoder`方法。
我们可以认为，只要实现了`Encoder`和`Decoder`方法的数据结构，就是序列化器。
kubernetes目前支持3种主要的序列化器：
- jsonSerializer：JSON格式序列化/反序列化器，使用`application/json`作为标识
- yamlSerializer：YAML格式序列化/反序列化器，使用`application/yaml`作为标识
- protobufSerializer：Protobuf格式序列化/反序列化器，使用`application/vnd.kubernetes.protobuf`作为标识

#### Codec编解码实例化

[staging/src/k8s.io/apimachinery/pkg/runtime/serializer/codec_factory.go]
```go
func newSerializersForScheme(scheme *runtime.Scheme, mf json.MetaFactory, options CodecFactoryOptions) []serializerType {
	jsonSerializer := json.NewSerializerWithOptions(
		mf, scheme, scheme,
		json.SerializerOptions{Yaml: false, Pretty: false, Strict: options.Strict},
	)
	jsonSerializerType := serializerType{
		AcceptContentTypes: []string{runtime.ContentTypeJSON},
		ContentType:        runtime.ContentTypeJSON,
		FileExtensions:     []string{"json"},
		EncodesAsText:      true,
		Serializer:         jsonSerializer,

		Framer:           json.Framer,
		StreamSerializer: jsonSerializer,
	}
	...

	yamlSerializer := json.NewSerializerWithOptions(
		mf, scheme, scheme,
		json.SerializerOptions{Yaml: true, Pretty: false, Strict: options.Strict},
	)
	protoSerializer := protobuf.NewSerializer(scheme, scheme)
	protoRawSerializer := protobuf.NewRawSerializer(scheme, scheme)

	serializers := []serializerType{
		jsonSerializerType,
		{
			AcceptContentTypes: []string{runtime.ContentTypeYAML},
			ContentType:        runtime.ContentTypeYAML,
			FileExtensions:     []string{"yaml"},
			EncodesAsText:      true,
			Serializer:         yamlSerializer,
		},
		{
			AcceptContentTypes: []string{runtime.ContentTypeProtobuf},
			ContentType:        runtime.ContentTypeProtobuf,
			FileExtensions:     []string{"pb"},
			Serializer:         protoSerializer,

			Framer:           protobuf.LengthDelimitedFramer,
			StreamSerializer: protoRawSerializer,
		},
	}
    ...
	return serializers
}
```

序列化操作[staging/src/k8s.io/apimachinery/pkg/runtime/serializer/json/json.go]
```go
func (s *Serializer) Encode(obj runtime.Object, w io.Writer) error {
	if co, ok := obj.(runtime.CacheableObject); ok {
		return co.CacheEncode(s.Identifier(), s.doEncode, w)
	}
	return s.doEncode(obj, w)
}

func (s *Serializer) doEncode(obj runtime.Object, w io.Writer) error {
	if s.options.Yaml {
		json, err := caseSensitiveJSONIterator.Marshal(obj)
		if err != nil {
			return err
		}
		data, err := yaml.JSONToYAML(json)
		if err != nil {
			return err
		}
		_, err = w.Write(data)
		return err
	}

	if s.options.Pretty {
		data, err := caseSensitiveJSONIterator.MarshalIndent(obj, "", "  ")
		if err != nil {
			return err
		}
		_, err = w.Write(data)
		return err
	}
	encoder := json.NewEncoder(w)
	return encoder.Encode(obj)
}
```
支持两种格式的序列化操作。

如果是YAML格式，通过`caseSensitiveJSONIterator.Marshal`函数将资源转成JSON格式，然后通过`yaml.JSONToYAML`将json格式转换为YAML格式并返回数据。

如果是JSON格式，通过Go语言标准库`json.NewEncoder`函数将资源对象转换为JSON格式，如果开启pretty通过`caseSensitiveJSONIterator.MarshalIndent`函数优化JSON格式。

protobuf序列化[staging/src/k8s.io/apimachinery/pkg/runtime/serializer/protobuf/protobuf.go]
```go
func (s *RawSerializer) Encode(obj runtime.Object, w io.Writer) error {
	if co, ok := obj.(runtime.CacheableObject); ok {
		return co.CacheEncode(s.Identifier(), s.doEncode, w)
	}
	return s.doEncode(obj, w)
}

func (s *RawSerializer) doEncode(obj runtime.Object, w io.Writer) error {
	switch t := obj.(type) {
	case bufferedReverseMarshaller:
		// this path performs a single allocation during write but requires the caller to implement
		// the more efficient Size and MarshalToSizedBuffer methods
		encodedSize := uint64(t.Size())
		data := make([]byte, encodedSize)

		n, err := t.MarshalToSizedBuffer(data)
		if err != nil {
			return err
		}
		_, err = w.Write(data[:n])
		return err

	case bufferedMarshaller:
		// this path performs a single allocation during write but requires the caller to implement
		// the more efficient Size and MarshalTo methods
		encodedSize := uint64(t.Size())
		data := make([]byte, encodedSize)

		n, err := t.MarshalTo(data)
		if err != nil {
			return err
		}
		_, err = w.Write(data[:n])
		return err

	case proto.Marshaler:
		// this path performs extra allocations
		data, err := t.Marshal()
		if err != nil {
			return err
		}
		_, err = w.Write(data)
		return err

	default:
		return errNotMarshalable{reflect.TypeOf(obj)}
	}
}
```
验证资源对象是否为`proto.Marshaler`类型，`proto.Marshaler`是一个interface接口类型，该结构专门留给对象自定义实现的序列化操作。

### Convert资源版本转换器

同一资源拥有多个版本，可以通过`kubectl convert`命令进行资源版本转换。`kubectl convert -f dp.yaml --output-version=apps/v1`

首先定义一个YAML Manifest File资源描述文件，该文件中定义Deployment资源版本为v1beta1，通过`kubectl convert`命令，`--output-version`将资源版本转换为指定的资源版本`v1`。
如果指定的资源版本不再Scheme资源注册表中，会报错。如果不指定资源版本，则默认转换为资源的首选版本。

当需要在两个资源版本之间进行转换时，会将第一个资源版本转换为`_internal`内部版本，在转换为相应的资源版本。
[staging/src/k8s.io/apimachinery/pkg/conversion/converter.go]
```go
type Converter struct {
    // 默认转换函数，这些转换函数一般定义在资源目录下的converter.go
	conversionFuncs          ConversionFuncs
    // 自动生成的转换函数，这些转换函数一般定义在资源目录的zz_generated.conversion.go代码文件中，是由代码生成器自动生成的转换函数
	generatedConversionFuncs ConversionFuncs
    // 若注册对象注册到此资源，则忽略此资源对象的转换操作
	ignoredConversions        map[typePair]struct{}
	ignoredUntypedConversions map[typePair]struct{}
    // 在转化过程中其用于获取资源种类的名称，该函数被定义[staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go]中
	nameFunc func(t reflect.Type) string
}
```

#### Converter注册转换函数
- scheme.AddIgnoredConversionType：注册忽略的资源类型，不会执行转换操作，忽略资源对象的转换操作
- scheme.AddConversionFunc：注册单个Conversion Func转换函数
- scheme.AddGeneratedConversionFunc：注册自动生成的转换函数
- scheme.AddFieldLabelConversionFunc：注册字段标签（FieldLabel）的转换函数

